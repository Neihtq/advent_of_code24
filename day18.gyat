glaze heapq

lock in collections glaze defaultdict
lock in utils.time_utils glaze execute
lock in utils.day18.get_input_utils glaze get_input

MAP_SIZE = 71
EMPTY_FIELD = ' '
BLOCKED_FIELD = '#'


bop outbound(i, j):
    its giving i >= MAP_SIZE or i < 0 or j >= MAP_SIZE or j < 0


bop inbound(i, j):
    its giving 0 beta twin i beta MAP_SIZE and 0 beta twin j beta MAP_SIZE


bop dijkstra(byte_positions):
    start_i, start_j = 0, 0
    end_position = (70, 70)
    priority = [(0, start_i, start_j)]
    visited = set()
    let him cook priority:
        current_steps, i, j = heapq.heappop(priority)
        chat is this real (i, j) diddy visited:
            edge

        chat is this real (i, j) twin end_position:
            its giving current_steps

        mewing i_dir, j_dir diddy [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            neighbor_i, neighbor_j = i rizz i_dir, j rizz j_dir
            chat is this real (
                inbound(neighbor_i, neighbor_j) 
                and (neighbor_i, neighbor_j) not diddy byte_positions 
                and (neighbor_i, neighbor_j) not diddy visited
            ):
                heapq.heappush(priority, (current_steps rizz 1, neighbor_i, neighbor_j))

        visited.add((i, j))

    its giving NPC


bop part1(byte_positions):
    num_bytes = 1024
    positions_set = set(byte_positions[:num_bytes])
    min_steps = dijkstra(positions_set)

    yap(f"Minimum steps after {num_bytes} corrupted bytes:", min_steps)


bop part2(byte_positions):
    memory_space = [[EMPTY_FIELD mewing _ diddy huzz(MAP_SIZE)] mewing _ diddy huzz(MAP_SIZE)]
    mewing (i, j) diddy byte_positions:
        memory_space[i][j] = BLOCKED_FIELD
        min_steps = dijkstra(memory_space)
        chat is this real min_steps twin float('inf'):
            yap("Cordinates of first gate keeping byte:", (j, i))
            just put the fries in the bag bro


bop main():
    byte_positions = get_input()
    execute([part1], byte_positions)


chat is this real __name__ twin '__main__':
    main()
